<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#init">init()</a></li>
      <li><a href="#eval">eval()</a></li>
      <li><a href="#deriv">deriv()</a></li>
      <li><a href="#deriv2">deriv2()</a></li>
      <li><a href="#integ">integ()</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::GSL::INTERP - PDL interface to Interpolation routines in GSL</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This is an interface to the interpolation package present in the GNU Scientific Library.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>   use PDL;
   use PDL::GSL::INTERP;

   my $x = sequence(10);
   my $y = exp($x);

   my $spl = PDL::GSL::INTERP-&gt;init(&#39;cspline&#39;,$x,$y);

   my $res = $spl-&gt;eval(4.35);
   $res = $spl-&gt;deriv(4.35);
   $res = $spl-&gt;deriv2(4.35);
   $res = $spl-&gt;integ(2.1,7.4);</code></pre>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="init">init()</h2>

<p>The init method initializes a new instance of INTERP. It needs as input an interpolation type and two piddles holding the x and y values to be interpolated. The GSL routines require that x be monotonically increasing and a quicksort is performed by default to ensure that. You can skip the quicksort by passing the option {Sort =&gt; 0}.</p>

<p>The available interpolation types are :</p>

<dl>

<dt id="linear">linear</dt>
<dd>

</dd>
<dt id="polynomial">polynomial</dt>
<dd>

</dd>
<dt id="cspline-natural-cubic-spline">cspline (natural cubic spline)</dt>
<dd>

</dd>
<dt id="cspline_periodic-periodic-cubic-spline">cspline_periodic (periodic cubic spline)</dt>
<dd>

</dd>
<dt id="akima-natural-akima-spline">akima (natural akima spline)</dt>
<dd>

</dd>
<dt id="akima_periodic-periodic-akima-spline">akima_periodic (periodic akima spline)</dt>
<dd>

</dd>
</dl>

<p>Please check the GSL documentation for more information.</p>

<p>Usage:</p>

<pre><code>    $blessed_ref = PDL::GSL::INTERP-&gt;init($interp_method,$x,$y,$opt);</code></pre>

<p>Example:</p>

<pre><code>    $x = sequence(10);
    $y = exp($x);

    $spl = PDL::GSL::INTERP-&gt;init(&#39;cspline&#39;,$x,$y)
    $spl = PDL::GSL::INTERP-&gt;init(&#39;cspline&#39;,$x,$y,{Sort =&gt; 1}) #same as above

    # no sorting done on x, user is certain that x is monotonically increasing
    $spl = PDL::GSL::INTERP-&gt;init(&#39;cspline&#39;,$x,$y,{Sort =&gt; 0});</code></pre>

<h2 id="eval">eval()</h2>

<p>The function eval returns the interpolating function at a given point. By default it will barf if you try to extrapolate, to comply silently if the point to be evaluated is out of range pass the option {Extrapolate =&gt; 1}</p>

<p>Usage:</p>

<pre><code>    $result = $spl-&gt;eval($points,$opt);</code></pre>

<p>Example:</p>

<pre><code>    my $res = $spl-&gt;eval($x)
    $res = $spl-&gt;eval($x,{Extrapolate =&gt; 0}) #same as above

    # silently comply if $x is out of range
    $res = $spl-&gt;eval($x,{Extrapolate =&gt; 1})</code></pre>

<h2 id="deriv">deriv()</h2>

<p>The deriv function returns the derivative of the interpolating function at a given point. By default it will barf if you try to extrapolate, to comply silently if the point to be evaluated is out of range pass the option {Extrapolate =&gt; 1}</p>

<p>Usage:</p>

<pre><code>    $result = $spl-&gt;deriv($points,$opt);</code></pre>

<p>Example:</p>

<pre><code>    my $res = $spl-&gt;deriv($x)
    $res = $spl-&gt;deriv($x,{Extrapolate =&gt; 0}) #same as above

    # silently comply if $x is out of range
    $res = $spl-&gt;deriv($x,{Extrapolate =&gt; 1})</code></pre>

<h2 id="deriv2">deriv2()</h2>

<p>The deriv2 function returns the second derivative of the interpolating function at a given point. By default it will barf if you try to extrapolate, to comply silently if the point to be evaluated is out of range pass the option {Extrapolate =&gt; 1}</p>

<p>Usage:</p>

<pre><code>    $result = $spl-&gt;deriv2($points,$opt);</code></pre>

<p>Example:</p>

<pre><code>    my $res = $spl-&gt;deriv2($x)
    $res = $spl-&gt;deriv2($x,{Extrapolate =&gt; 0}) #same as above

    # silently comply if $x is out of range
    $res = $spl-&gt;deriv2($x,{Extrapolate =&gt; 1})</code></pre>

<h2 id="integ">integ()</h2>

<p>The integ function returns the integral of the interpolating function between two points. By default it will barf if you try to extrapolate, to comply silently if one of the integration limits is out of range pass the option {Extrapolate =&gt; 1}</p>

<p>Usage:</p>

<pre><code>    $result = $spl-&gt;integ($a,$b,$opt);</code></pre>

<p>Example:</p>

<pre><code>    my $res = $spl-&gt;integ($a,$b)
    $res = $spl-&gt;integ($a,$b,{Extrapolate =&gt; 0}) #same as above

    # silently comply if $a or $b are out of range
    $res = $spl-&gt;eval($a,$b,{Extrapolate =&gt; 1})</code></pre>

<h1 id="BUGS">BUGS</h1>

<p>Feedback is welcome.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../.\PDL.html">PDL</a></p>

<p>The GSL documentation is online at</p>

<pre><code>  http://www.gnu.org/software/gsl/manual/</code></pre>

<h1 id="AUTHOR">AUTHOR</h1>

<p>This file copyright (C) 2003 Andres Jordan &lt;andresj@physics.rutgers.edu&gt; All rights reserved. There is no warranty. You are allowed to redistribute this software/documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>

<p>The GSL interpolation module was written by Gerard Jungman.</p>


</body>

</html>


