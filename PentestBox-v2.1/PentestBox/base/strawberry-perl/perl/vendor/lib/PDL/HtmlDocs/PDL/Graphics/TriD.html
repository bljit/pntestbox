<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#WARNING">WARNING</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SELECTING-A-DEVICE">SELECTING A DEVICE</a></li>
  <li><a href="#ONLINE-AND-OFFLINE-VISUALIZATION">ONLINE AND OFFLINE VISUALIZATION</a></li>
  <li><a href="#COORDINATE-SPECIFICATIONS">COORDINATE SPECIFICATIONS</a>
    <ul>
      <li><a href="#Wrapping-your-head-around-3d-surface-specifications">Wrapping your head around 3d surface specifications</a></li>
    </ul>
  </li>
  <li><a href="#SIMPLE-ROUTINES">SIMPLE ROUTINES</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#line3d">line3d</a></li>
      <li><a href="#imag3d">imag3d</a></li>
      <li><a href="#mesh3d">mesh3d</a></li>
      <li><a href="#lattice3d">lattice3d</a></li>
      <li><a href="#points3d">points3d</a></li>
      <li><a href="#spheres3d">spheres3d</a></li>
      <li><a href="#imagrgb">imagrgb</a></li>
      <li><a href="#imagrgb3d">imagrgb3d</a></li>
      <li><a href="#grabpic3d">grabpic3d</a></li>
      <li><a href="#hold3d-release3d">hold3d, release3d</a></li>
      <li><a href="#keeptwiddling3d-nokeeptwiddling3d">keeptwiddling3d, nokeeptwiddling3d</a></li>
      <li><a href="#twiddle3d">twiddle3d</a></li>
    </ul>
  </li>
  <li><a href="#CONCEPTS">CONCEPTS</a>
    <ul>
      <li><a href="#Object">Object</a></li>
      <li><a href="#Twiddling">Twiddling</a></li>
    </ul>
  </li>
  <li><a href="#OBJECTS">OBJECTS</a>
    <ul>
      <li><a href="#PDL::Graphics::TriD::LineStrip">PDL::Graphics::TriD::LineStrip</a></li>
      <li><a href="#PDL::Graphics::TriD::Lines">PDL::Graphics::TriD::Lines</a></li>
      <li><a href="#PDL::Graphics::TriD::Image">PDL::Graphics::TriD::Image</a></li>
      <li><a href="#PDL::Graphics::TriD::Lattice">PDL::Graphics::TriD::Lattice</a></li>
      <li><a href="#PDL::Graphics::TriD::Points">PDL::Graphics::TriD::Points</a></li>
      <li><a href="#PDL::Graphics::TriD::Scale-x-y-z">PDL::Graphics::TriD::Scale(x,y,z)</a></li>
      <li><a href="#PDL::Graphics::TriD::Translation-x-y-z">PDL::Graphics::TriD::Translation(x,y,z)</a></li>
      <li><a href="#PDL::Graphics::TriD::Quaternion-c-x-y-z">PDL::Graphics::TriD::Quaternion(c,x,y,z)</a></li>
      <li><a href="#PDL::Graphics::TriD::ViewPort">PDL::Graphics::TriD::ViewPort</a></li>
    </ul>
  </li>
  <li><a href="#EXAMPLE-SCRIPT-FOR-VARIOUS">EXAMPLE SCRIPT FOR VARIOUS</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Graphics::TriD -- PDL 3D interface</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> use PDL::Graphics::TriD;
 
 # Generate a somewhat interesting sequence of points:
 $t = sequence(100)/10;
 $x = sin($t); $y = cos($t), $z = $t;
 $coords = cat($x, $y, $z)-&gt;xchg(0,1);
 $r = cos(2*$t); $g = sin($t); $b = $t;
 $colors = cat($r, $g, $b)-&gt;xchg(0,1);
 
 # After each graph, let the user rotate and
 # wait for him to press &#39;q&#39;, then make new graph
 line3d($coords);       # $coords = (3,n,...)
 line3d($coords,$colors);  # $colors = (3,n,...)
 line3d([$x,$y,$z]);
 
 # Generate a somewhat interesting sequence of surfaces
 $surf1 = (rvals(100, 100) / 50)**2 + sin(xvals(100, 100) / 10);
 $surf2 = sqrt(rvals(zeroes(50,50))/2);
 $x = sin($surface); $y = cos($surface), $z = $surface;
 $coords = cat($x, $y, $z)-&gt;xchg(0,1);
 $r = cos(2*$surface); $g = sin($surface); $b = $surface;
 $colors = cat($r, $g, $b)-&gt;xchg(0,1);
 imagrgb([$r,$g,$b]);     # 2-d piddles
 lattice3d([$surf1]);
 points3d([$x,$y,$z]);
 spheres3d([$x,$y,$z]);  # preliminary implementation

 hold3d(); # the following graphs are on top of each other and the previous
 line3d([$x,$y,$z]);
 line3d([$x,$y,$z+1]);
 $pic = grabpic3d(); # Returns the picture in a (3,$x,$y) float piddle (0..1).

 release3d(); # the next graph will again wipe out things.</code></pre>

<h1 id="WARNING">WARNING</h1>

<p>These modules are still in a somewhat unfocused state: don&#39;t use them yet if you don&#39;t know how to make them work if they happen to do something strange.</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module implements a generic 3D plotting interface for PDL. Points, lines and surfaces (among other objects) are supported.</p>

<p>With OpenGL, it is easy to manipulate the resulting 3D objects with the mouse in real time - this helps data visualization a lot.</p>

<h1 id="SELECTING-A-DEVICE">SELECTING A DEVICE</h1>

<p>The default device for TriD is currently OpenGL. You can specify a different device either in your program or in the environment variable <code>PDL_3D_DEVICE</code>. The one specified in the program takes priority.</p>

<p>The currently available devices are</p>

<dl>

<dt id="GL">GL</dt>
<dd>

<p>OpenGL</p>

</dd>
<dt id="GLpic">GLpic</dt>
<dd>

<p>OpenGL but off-line (pixmap) rendering and writing to a graphics file.</p>

</dd>
<dt id="VRML-Not-available-this-release">VRML (<i> Not available this release </i>)</dt>
<dd>

<p>VRML objects rendering. This writes a VRML file describing the scene. This VRML file can then be read with a browser.</p>

</dd>
</dl>

<h1 id="ONLINE-AND-OFFLINE-VISUALIZATION">ONLINE AND OFFLINE VISUALIZATION</h1>

<p>TriD offers both on- and off-line visualization. Currently the interface w.r.t. this division is still much in motion.</p>

<p>For OpenGL you can select either on- or off-line rendering. VRML is currently always offline (this may change later, if someone bothers to write the java(script) code to contact PDL and wait for the next PDL image over the network.</p>

<h1 id="COORDINATE-SPECIFICATIONS">COORDINATE SPECIFICATIONS</h1>

<p>Specifying a set of coordinates is generally a context-dependent operation. For a traditional 3D surface plot, you&#39;ll want two of the coordinates to have just the xvals and yvals of the piddle, respectively. For a line, you would generally want to have one coordinate held at zero and the other advancing.</p>

<p>This module tries to make a reasonable way of specifying the context while letting you do whatever you want by overriding the default interpretation.</p>

<p>The alternative syntaxes for specifying a set of coordinates (or colors) are</p>

<pre><code>   $piddle                             # MUST have 3 as first dim.
  [$piddle]
  [$piddle1,$piddle2]
  [$piddle1,$piddle2,$piddle3]
  [CONTEXT,$piddle]
  [CONTEXT,$piddle1,$piddle2]
  [CONTEXT,$piddle1,$piddle2,$piddle3]</code></pre>

<p>where <code>CONTEXT</code> is a string describing in which context you wish these piddles to be interpreted. Each routine specifies a default context which is explained in the routines documentation. Context is usually used only to understand what the user wants when he/she specifies less than 3 piddles.</p>

<p>The following contexts are currently supported:</p>

<dl>

<dt id="SURF2D">SURF2D</dt>
<dd>

<p>A 2-D lattice. <code> [$piddle] </code> is interpreted as the Z coordinate over a lattice over the first dimension. Equivalent to <code> [$piddle-</code>xvals, $piddle-&gt;yvals, $piddle] &gt;.</p>

</dd>
<dt id="POLAR2D">POLAR2D</dt>
<dd>

<p>A 2-D polar coordinate system. <code> [$piddle] </code> is interpreted as the z coordinate over theta and r (theta = the first dimension of the piddle).</p>

</dd>
<dt id="COLOR">COLOR</dt>
<dd>

<p>A set of colors. <code> [$piddle] </code> is interpreted as grayscale color (equivalent to <code> [$piddle,$piddle,$piddle] </code>).</p>

</dd>
<dt id="LINE">LINE</dt>
<dd>

<p>A line made of 1 or 2 coordinates. <code> [$piddle] </code> is interpreted as <code> [$piddle-</code>xvals,$piddle,0] &gt;. <code> [$piddle1,$piddle2] </code> is interpreted as <code> [$piddle1,$piddle2,$piddle1-</code>xvals] &gt;.</p>

</dd>
</dl>

<p>What makes contexts useful is that if you want to plot points instead of the full surface you plotted with</p>

<pre><code>  imag3d([$zcoords]);</code></pre>

<p>you don&#39;t need to start thinking about where to plot the points:</p>

<pre><code>  points3d([SURF2D,$zcoords]);</code></pre>

<p>will do exactly the same.</p>

<h2 id="Wrapping-your-head-around-3d-surface-specifications">Wrapping your head around 3d surface specifications</h2>

<p>Let&#39;s begin by thnking about how you might make a 2d data plot. If you sampled your data at regular intervals, you would have a time serires y(t) = (y0, y1, y2, ...). You could plot y vs t by computing t0 = 0, t1 = dt, t2 = 2 * dt, and then plotting (t0, y0), (t1, y1), etc.</p>

<p>Next suppose that you measured x(t) and y(t). You can still plot y vs t, but you can also plot y vs x by plotting (x0, y0), (x1, y1), etc. The x-values don&#39;t have to increase monotonically: they could back-track on each other, for example, like the latitude and longitude of a boat on a lake. If you use plplot, you would plot this data using <code>$pl-&gt;xyplot($x, $y, PLOTTYPE =&gt; &#39;POINTS&#39;)</code>.</p>

<p>Good. Now let&#39;s add a third coordinate, z(t). If you actually sampled x and y at regular intervals, so that x and y lie on a grid, then you can construct a grid for z(x, y), and you would get a surface. This is the situation in which you would use <code>mesh3d([$surface])</code>.</p>

<p>Of course, your data is not required to be regularly gridded. You could, for example, be measuring the flight path of a bat flying after mosquitos, which could be wheeling and arching all over the space. This is what you might plot using <code>line3d([$x, $y, $z])</code>. You could plot the trajectories of multiple bats, in which case <code>$x</code>, <code>$y</code>, and <code>$z</code> would have multiple columns, but in general you wouldn&#39;t expect them to be coordinated.</p>

<p>Finally, imagine that you have an air squadron flying in formation. Your (x, y, z) data is not regularly gridded, but the (x, y, z) data for each plane should be coordinated and we can imagine that their flight path sweep out a surface. We could draw this data using <code>line3d([$x, $y, $z])</code>, where each column in the variables corresponds to a different plane, but it would also make sense to draw this data using <code>mesh3d([$x, $y, $z])</code>, since the planes&#39; proximity to each other should be fairly consistent. In other words, it makes sense to think of the planes as sweeping out a coordinated surface, which <code>mesh3d</code> would draw for you, whereas you would not expect the trajectories of the various bats to describe a meaningful surface (unless you&#39;re into fractals, perhaps).</p>

<pre><code> #!/usr/bin/perl

 use PDL;
 use PDL::Graphics::TriD;

 # Draw out a trajectory in three-space
 $t = sequence(100)/10;
 $x = sin($t); $y = cos($t); $z = $t;

 # Plot the trajectory as (x(t), y(t), z(t))
 print &quot;using line3d to plot a trajectory (press q when you&#39;re done twiddling)\n&quot;;
 line3d [$x,$y,$z];

 # If you give it a single piddle, it expects
 # the data to look like
 # ((x1, y1, z1), (x2, y2, z2), ...)
 # which is why we have to do the exchange:
 $coords = cat($x, $y, $z)-&gt;xchg(0,1);
 print &quot;again, with a different coordinate syntax (press q when you&#39;re done twiddling)\n&quot;;
 line3d $coords;

 # Draw a regularly-gridded surface:
 $surface = sqrt(rvals(zeroes(50,50))/2);
 print &quot;draw a mesh of a regularly-gridded surface using mesh3d\n&quot;;
 mesh3d [$surface];
 print &quot;draw a regularly-gridded surface using imag3d\n&quot;;
 imag3d [$surface], {Lines=&gt;0};

 # Draw a mobius strip:
 $two_pi = 8 * atan2(1,1);
 $t = sequence(50) / 50 * $two_pi;
 # We want two paths:
 $mobius1_x = cos($t) + 0.5 * sin($t/2);
 $mobius2_x = cos($t);
 $mobius3_x = cos($t) - 0.5 * sin($t/2);
 $mobius1_y = sin($t) + 0.5 * sin($t/2);
 $mobius2_y = sin($t);
 $mobius3_y = sin($t) - 0.5 * sin($t/2);
 $mobius1_z = $t - $two_pi/2;
 $mobius2_z = zeroes($t);
 $mobius3_z = $two_pi/2 - $t;

 $mobius_x = cat($mobius1_x, $mobius2_x, $mobius3_x);
 $mobius_y = cat($mobius1_y, $mobius2_y, $mobius3_y);
 $mobius_z = cat($mobius1_z, $mobius2_z, $mobius3_z);

 $mobius_surface = cat($mobius_x, $mobius_y, $mobius_z)-&gt;mv(2,0);

 print &quot;A mobius strip using line3d one way\n&quot;;
 line3d $mobius_surface;
 print &quot;A mobius strip using line3d the other way\n&quot;;
 line3d $mobius_surface-&gt;xchg(1,2);
 print &quot;A mobius strip using mesh3d\n&quot;;
 mesh3d $mobius_surface;
 print &quot;The same mobius strip using imag3d\n&quot;;
 imag3d $mobius_surface, {Lines =&gt; 0};</code></pre>

<h1 id="SIMPLE-ROUTINES">SIMPLE ROUTINES</h1>

<p>Because using the whole object-oriented interface for doing all your work might be cumbersome, the following shortcut routines are supported:</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="line3d">line3d</h2>

<p>3D line plot, defined by a variety of contexts.</p>

<pre><code> line3d piddle(3,x), {OPTIONS}
 line3d [CONTEXT], {OPTIONS}</code></pre>

<p>Example:</p>

<pre><code> pdl&gt; line3d [sqrt(rvals(zeroes(50,50))/2)]
 - Lines on surface
 pdl&gt; line3d [$x,$y,$z]
 - Lines over X, Y, Z
 pdl&gt; line3d $coords
 - Lines over the 3D coordinates in $coords.</code></pre>

<p>Note: line plots differ from mesh plots in that lines only go in one direction. If this is unclear try both!</p>

<p>See module documentation for more information on contexts and options</p>

<h2 id="imag3d">imag3d</h2>

<p>3D rendered image plot, defined by a variety of contexts</p>

<pre><code> imag3d piddle(3,x,y), {OPTIONS}
 imag3d [piddle,...], {OPTIONS}</code></pre>

<p>Example:</p>

<pre><code> pdl&gt; imag3d [sqrt(rvals(zeroes(50,50))/2)], {Lines=&gt;0};

 - Rendered image of surface</code></pre>

<p>See module documentation for more information on contexts and options</p>

<h2 id="mesh3d">mesh3d</h2>

<p>3D mesh plot, defined by a variety of contexts</p>

<pre><code> mesh3d piddle(3,x,y), {OPTIONS}
 mesh3d [piddle,...], {OPTIONS}</code></pre>

<p>Example:</p>

<pre><code> pdl&gt; mesh3d [sqrt(rvals(zeroes(50,50))/2)]

 - mesh of surface</code></pre>

<p>Note: a mesh is defined by two sets of lines at right-angles (i.e. this is how is differs from line3d).</p>

<p>See module documentation for more information on contexts and options</p>

<h2 id="lattice3d">lattice3d</h2>

<p>alias for mesh3d</p>

<h2 id="points3d">points3d</h2>

<p>3D points plot, defined by a variety of contexts</p>

<pre><code> points3d piddle(3), {OPTIONS}
 points3d [piddle,...], {OPTIONS}</code></pre>

<p>Example:</p>

<pre><code> pdl&gt; points3d [sqrt(rvals(zeroes(50,50))/2)];
 - points on surface</code></pre>

<p>See module documentation for more information on contexts and options</p>

<h2 id="spheres3d">spheres3d</h2>

<p>3D spheres plot (preliminary implementation)</p>

<pre><code> spheres3d piddle(3), {OPTIONS}
 spheres3d [piddle,...], {OPTIONS}</code></pre>

<p>Example:</p>

<pre><code> pdl&gt; spheres3d ndcoords(10,10,10)-&gt;clump(1,2,3)  
 
 - lattice of spheres at coordinates on 10x10x10 grid</code></pre>

<p>This is a preliminary implementation as a proof of concept. It has fixed radii for the spheres being drawn and no control of color or transparency.</p>

<h2 id="imagrgb">imagrgb</h2>

<p>2D RGB image plot (see also imag2d)</p>

<pre><code> imagrgb piddle(3,x,y), {OPTIONS}
 imagrgb [piddle,...], {OPTIONS}</code></pre>

<p>This would be used to plot an image, specifying red, green and blue values at each point. Note: contexts are very useful here as there are many ways one might want to do this.</p>

<p>e.g.</p>

<pre><code> pdl&gt; $a=sqrt(rvals(zeroes(50,50))/2)
 pdl&gt; imagrgb [0.5*sin(8*$a)+0.5,0.5*cos(8*$a)+0.5,0.5*cos(4*$a)+0.5]</code></pre>

<h2 id="imagrgb3d">imagrgb3d</h2>

<p>2D RGB image plot as an object inside a 3D space</p>

<pre><code> imagrdb3d piddle(3,x,y), {OPTIONS}
 imagrdb3d [piddle,...], {OPTIONS}</code></pre>

<p>The piddle gives the colors. The option allowed is Points, which should give 4 3D coordinates for the corners of the polygon, either as a piddle or as array ref. The default is [[0,0,0],[1,0,0],[1,1,0],[0,1,0]].</p>

<p>e.g.</p>

<pre><code> pdl&gt; imagrgb3d $colors, {Points =&gt; [[0,0,0],[1,0,0],[1,0,1],[0,0,1]]};
 - plot on XZ plane instead of XY.</code></pre>

<h2 id="grabpic3d">grabpic3d</h2>

<p>Grab a 3D image from the screen.</p>

<pre><code> $pic = grabpic3d();</code></pre>

<p>The returned piddle has dimensions (3,$x,$y) and is of type float (currently). XXX This should be altered later.</p>

<h2 id="hold3d-release3d">hold3d, release3d</h2>

<p>Keep / don&#39;t keep the previous objects when plotting new 3D objects</p>

<pre><code> hold3d();
 release3d();</code></pre>

<p>or</p>

<pre><code> hold3d(1);
 hold3d(0);</code></pre>

<h2 id="keeptwiddling3d-nokeeptwiddling3d">keeptwiddling3d, nokeeptwiddling3d</h2>

<p>Wait / don&#39;t wait for &#39;q&#39; after displaying a 3D image.</p>

<p>Usually, when showing 3D images, the user is given a chance to rotate it and then press &#39;q&#39; for the next image. However, sometimes (for e.g. animation) this is undesirable and it is more desirable to just run one step of the event loop at a time.</p>

<pre><code> keeptwiddling3d();
 nokeeptwiddling3d();</code></pre>

<p>or</p>

<pre><code> keeptwiddling3d(1);
 keeptwiddling3d(0);</code></pre>

<p>When an image is added to the screen, keep twiddling it until user explicitly presses &#39;q&#39;.</p>

<pre><code> keeptwiddling3d();
 imag3d(..);
 nokeeptwiddling3d();
 $o = imag3d($c);
 while(1) {
        $c .= nextfunc($c);
        $o-&gt;data_changed();
        twiddle3d();            # animate one step, then return.
 }</code></pre>

<h2 id="twiddle3d">twiddle3d</h2>

<p>Wait for the user to rotate the image in 3D space.</p>

<p>Let the user rotate the image in 3D space, either for one step or until (s)he presses &#39;q&#39;, depending on the &#39;keeptwiddling3d&#39; setting. If &#39;keeptwiddling3d&#39; is not set the routine returns immediately and indicates that a &#39;q&#39; event was received by returning 1. If the only events received were mouse events, returns 0.</p>

<h1 id="CONCEPTS">CONCEPTS</h1>

<p>The key concepts (object types) of TriD are explained in the following:</p>

<h2 id="Object">Object</h2>

<p>In this 3D abstraction, everything that you can &quot;draw&quot; without using indices is an Object. That is, if you have a surface, each vertex is not an object and neither is each segment of a long curve. The whole curve (or a set of curves) is the lowest level Object.</p>

<p>Transformations and groups of Objects are also Objects.</p>

<p>A Window is simply an Object that has subobjects.</p>

<h2 id="Twiddling">Twiddling</h2>

<p>Because there is no eventloop in Perl yet and because it would be hassleful to do otherwise, it is currently not possible to e.g. rotate objects with your mouse when the console is expecting input or the program is doing other things. Therefore, you need to explicitly say &quot;$window-&gt;twiddle()&quot; in order to display anything.</p>

<h1 id="OBJECTS">OBJECTS</h1>

<p>The following types of objects are currently supported. Those that do not have a calling sequence described here should have their own manual pages.</p>

<p>There are objects that are not mentioned here; they are either internal to PDL3D or in rapidly changing states. If you use them, you do so at your own risk.</p>

<p>The syntax <code>PDL::Graphics::TriD::Scale(x,y,z)</code> here means that you create an object like</p>

<pre><code>        $a = new PDL::Graphics::TriD::Scale($x,$y,$z);</code></pre>

<h2 id="PDL::Graphics::TriD::LineStrip">PDL::Graphics::TriD::LineStrip</h2>

<p>This is just a line or a set of lines. The arguments are 3 1-or-more-D piddles which describe the vertices of a continuous line and an optional color piddle (which is 1-D also and simply defines the color between red and blue. This will probably change).</p>

<h2 id="PDL::Graphics::TriD::Lines">PDL::Graphics::TriD::Lines</h2>

<p>This is just a line or a set of lines. The arguments are 3 1-or-more-D piddles where each contiguous pair of vertices describe a line segment and an optional color piddle (which is 1-D also and simply defines the color between red and blue. This will probably change).</p>

<h2 id="PDL::Graphics::TriD::Image">PDL::Graphics::TriD::Image</h2>

<p>This is a 2-dimensional RGB image consisting of colored rectangles. With OpenGL, this is implemented by texturing so this should be relatively memory and execution-time-friendly.</p>

<h2 id="PDL::Graphics::TriD::Lattice">PDL::Graphics::TriD::Lattice</h2>

<p>This is a 2-D set of points connected by lines in 3-space. The constructor takes as arguments 3 2-dimensional piddles.</p>

<h2 id="PDL::Graphics::TriD::Points">PDL::Graphics::TriD::Points</h2>

<p>This is simply a set of points in 3-space. Takes as arguments the x, y and z coordinates of the points as piddles.</p>

<h2 id="PDL::Graphics::TriD::Scale-x-y-z">PDL::Graphics::TriD::Scale(x,y,z)</h2>

<p>Self-explanatory</p>

<h2 id="PDL::Graphics::TriD::Translation-x-y-z">PDL::Graphics::TriD::Translation(x,y,z)</h2>

<p>Ditto</p>

<h2 id="PDL::Graphics::TriD::Quaternion-c-x-y-z">PDL::Graphics::TriD::Quaternion(c,x,y,z)</h2>

<p>One way of representing rotations is with quaternions. See the appropriate man page.</p>

<h2 id="PDL::Graphics::TriD::ViewPort">PDL::Graphics::TriD::ViewPort</h2>

<p>This is a special class: in order to obtain a new viewport, you need to have an earlier viewport on hand. The usage is:</p>

<pre><code>  $new_vp = $old_vp-&gt;new_viewport($x0,$y0,$x1,$y1);</code></pre>

<p>where $x0 etc are the coordinates of the upper left and lower right corners of the new viewport inside the previous (relative to the previous viewport in the (0,1) range.</p>

<p>Every implementation-level window object should implement the new_viewport method.</p>

<h1 id="EXAMPLE-SCRIPT-FOR-VARIOUS">EXAMPLE SCRIPT FOR VARIOUS</h1>

<h1 id="BUGS">BUGS</h1>

<p>Not enough is there yet.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) 1997 Tuomas J. Lukka (lukka@husc.harvard.edu). Documentation contributions from Karl Glazebrook (kgb@aaoepp.aao.gov.au). All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>


</body>

</html>


