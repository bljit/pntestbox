<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Piecewise-cubic-Hermite-interpolation-PCHIP">Piecewise cubic Hermite interpolation (PCHIP)</a></li>
    </ul>
  </li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#eigsys">eigsys</a></li>
      <li><a href="#matinv">matinv</a></li>
      <li><a href="#polyfit">polyfit</a></li>
      <li><a href="#polycoef">polycoef</a></li>
      <li><a href="#polyvalue">polyvalue</a></li>
      <li><a href="#detslatec">detslatec</a></li>
      <li><a href="#fft">fft</a></li>
      <li><a href="#rfft">rfft</a></li>
      <li><a href="#svdc">svdc</a></li>
      <li><a href="#poco">poco</a></li>
      <li><a href="#geco">geco</a></li>
      <li><a href="#gefa">gefa</a></li>
      <li><a href="#podi">podi</a></li>
      <li><a href="#gedi">gedi</a></li>
      <li><a href="#gesl">gesl</a></li>
      <li><a href="#rs">rs</a></li>
      <li><a href="#ezffti">ezffti</a></li>
      <li><a href="#ezfftf">ezfftf</a></li>
      <li><a href="#ezfftb">ezfftb</a></li>
      <li><a href="#pcoef">pcoef</a></li>
      <li><a href="#pvalue">pvalue</a></li>
      <li><a href="#chim">chim</a></li>
      <li><a href="#chic">chic</a></li>
      <li><a href="#chsp">chsp</a></li>
      <li><a href="#chfd">chfd</a></li>
      <li><a href="#chfe">chfe</a></li>
      <li><a href="#chia">chia</a></li>
      <li><a href="#chid">chid</a></li>
      <li><a href="#chcm">chcm</a></li>
      <li><a href="#chbs">chbs</a></li>
      <li><a href="#polfit">polfit</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Slatec - PDL interface to the slatec numerical programming library</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> use PDL::Slatec;

 ($ndeg, $r, $ierr, $a) = polyfit($x, $y, $w, $maxdeg, $eps);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module serves the dual purpose of providing an interface to parts of the slatec library and showing how to interface PDL to an external library. Using this library requires a fortran compiler; the source for the routines is provided for convenience.</p>

<p>Currently available are routines to: manipulate matrices; calculate FFT&#39;s; fit data using polynomials; and interpolate/integrate data using piecewise cubic Hermite interpolation.</p>

<h2 id="Piecewise-cubic-Hermite-interpolation-PCHIP">Piecewise cubic Hermite interpolation (PCHIP)</h2>

<p>PCHIP is the slatec package of routines to perform piecewise cubic Hermite interpolation of data. It features software to produce a monotone and &quot;visually pleasing&quot; interpolant to monotone data. According to Fritsch &amp; Carlson (&quot;Monotone piecewise cubic interpolation&quot;, SIAM Journal on Numerical Analysis 17, 2 (April 1980), pp. 238-246), such an interpolant may be more reasonable than a cubic spline if the data contains both &quot;steep&quot; and &quot;flat&quot; sections. Interpolation of cumulative probability distribution functions is another application. These routines are cryptically named (blame FORTRAN), beginning with &#39;ch&#39;, and accept either float or double piddles.</p>

<p>Most of the routines require an integer parameter called <code>check</code>; if set to 0, then no checks on the validity of the input data are made, otherwise these checks are made. The value of <code>check</code> can be set to 0 if a routine such as <a href="#chim">chim</a> has already been successfully called.</p>

<ul>

<li><p>If not known, estimate derivative values for the points using the <a href="#chim">chim</a>, <a href="#chic">chic</a>, or <a href="#chsp">chsp</a> routines (the following routines require both the function (<code>f</code>) and derivative (<code>d</code>) values at a set of points (<code>x</code>)).</p>

</li>
<li><p>Evaluate, integrate, or differentiate the resulting PCH function using the routines: <a href="#chfd">chfd</a>; <a href="#chfe">chfe</a>; <a href="#chia">chia</a>; <a href="#chid">chid</a>.</p>

</li>
<li><p>If desired, you can check the monotonicity of your data using <a href="#chcm">chcm</a>.</p>

</li>
</ul>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="eigsys">eigsys</h2>

<p>Eigenvalues and eigenvectors of a real positive definite symmetric matrix.</p>

<pre><code> ($eigvals,$eigvecs) = eigsys($mat)</code></pre>

<p>Note: this function should be extended to calculate only eigenvalues if called in scalar context!</p>

<h2 id="matinv">matinv</h2>

<p>Inverse of a square matrix</p>

<pre><code> ($inv) = matinv($mat)</code></pre>

<h2 id="polyfit">polyfit</h2>

<p>Convenience wrapper routine about the <code>polfit</code> <code>slatec</code> function. Separates supplied arguments and return values.</p>

<p>Fit discrete data in a least squares sense by polynomials in one variable. Handles threading correctly--one can pass in a 2D PDL (as <code>$y</code>) and it will pass back a 2D PDL, the rows of which are the polynomial regression results (in <code>$r</code> corresponding to the rows of $y.</p>

<pre><code> ($ndeg, $r, $ierr, $a, $coeffs, $rms) = polyfit($x, $y, $w, $maxdeg, [$eps]);

 $coeffs = polyfit($x,$y,$w,$maxdeg,[$eps]);</code></pre>

<p>where on input:</p>

<p><code>$x</code> and <code>$y</code> are the values to fit to a polynomial. <code>$w</code> are weighting factors <code>$maxdeg</code> is the maximum degree of polynomial to use and <code>$eps</code> is the required degree of fit.</p>

<p>and the output switches on list/scalar context.</p>

<p>In list context:</p>

<p><code>$ndeg</code> is the degree of polynomial actually used <code>$r</code> is the values of the fitted polynomial <code>$ierr</code> is a return status code, and <code>$a</code> is some working array or other (preserved for historical purposes) <code>$coeffs</code> is the polynomial coefficients of the best fit polynomial. <code>$rms</code> is the rms error of the fit.</p>

<p>In scalar context, only $coeffs is returned.</p>

<p>Historically, <code>$eps</code> was modified in-place to be a return value of the rms error. This usage is deprecated, and <code>$eps</code> is an optional parameter now. It is still modified if present.</p>

<p><code>$a</code> is a working array accessible to Slatec - you can feed it to several other Slatec routines to get nice things out. It does not thread correctly and should probably be fixed by someone. If you are reading this, that someone might be you.</p>

<p>This version of polyfit handles bad values correctly. Bad values in $y are ignored for the fit and give computed values on the fitted curve in the return. Bad values in $x or $w are ignored for the fit and result in bad elements in the output.</p>

<h2 id="polycoef">polycoef</h2>

<p>Convenience wrapper routine around the <code>pcoef</code> <code>slatec</code> function. Separates supplied arguments and return values.</p>

<p>Convert the <code>polyfit</code>/<code>polfit</code> coefficients to Taylor series form.</p>

<pre><code> $tc = polycoef($l, $c, $a);</code></pre>

<h2 id="polyvalue">polyvalue</h2>

<p>Convenience wrapper routine around the <code>pvalue</code> <code>slatec</code> function. Separates supplied arguments and return values.</p>

<p>For multiple input x positions, a corresponding y position is calculated.</p>

<p>The derivatives PDL is one dimensional (of size <code>nder</code>) if a single x position is supplied, two dimensional if more than one x position is supplied.</p>

<p>Use the coefficients generated by <code>polyfit</code> (or <code>polfit</code>) to evaluate the polynomial fit of degree <code>l</code>, along with the first <code>nder</code> of its derivatives, at a specified point.</p>

<pre><code> ($yfit, $yp) = polyvalue($l, $nder, $x, $a);</code></pre>

<h2 id="detslatec">detslatec</h2>

<p>compute the determinant of an invertible matrix</p>

<pre><code>  $mat = zeroes(5,5); $mat-&gt;diagonal(0,1) .= 1; # unity matrix
  $det = detslatec $mat;</code></pre>

<p>Usage:</p>

<pre><code>  $determinant = detslatec $matrix;</code></pre>

<pre><code>  Signature: detslatec(mat(n,m); [o] det())</code></pre>

<p><code>detslatec</code> computes the determinant of an invertible matrix and barfs if the matrix argument provided is non-invertible. The matrix threads as usual.</p>

<p>This routine was previously known as <code>det</code> which clashes now with <a href="./MatrixOps.html#det">det</a> which is provided by <a href="./MatrixOps.html">PDL::MatrixOps</a>.</p>

<h2 id="fft">fft</h2>

<p>Fast Fourier Transform</p>

<pre><code>  $v_in = pdl(1,0,1,0);
  ($azero,$a,$b) = PDL::Slatec::fft($v_in);</code></pre>

<p><code>PDL::Slatec::fft</code> is a convenience wrapper for <a>ezfftf</a>, and performs a Fast Fourier Transform on an input vector <code>$v_in</code>. The return values are the same as for <a>ezfftf</a>.</p>

<h2 id="rfft">rfft</h2>

<p>reverse Fast Fourier Transform</p>

<pre><code>  $v_out = PDL::Slatec::rfft($azero,$a,$b);
  print $v_in, $vout
  [1 0 1 0] [1 0 1 0]</code></pre>

<p><code>PDL::Slatec::rfft</code> is a convenience wrapper for <a>ezfftb</a>, and performs a reverse Fast Fourier Transform. The input is the same as the output of <a href="#PDL::Slatec::fft">PDL::Slatec::fft</a>, and the output of <code>rfft</code> is a data vector, similar to what is input into <a href="#PDL::Slatec::fft">PDL::Slatec::fft</a>.</p>

<h2 id="svdc">svdc</h2>

<pre><code>  Signature: (x(n,p);[o]s(p);[o]e(p);[o]u(n,p);[o]v(p,p);[o]work(n);int job();int [o]info())</code></pre>

<p>singular value decomposition of a matrix</p>

<p>svdc does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="poco">poco</h2>

<pre><code>  Signature: (a(n,n);rcond();[o]z(n);int [o]info())</code></pre>

<p>Factor a real symmetric positive definite matrix and estimate the condition number of the matrix.</p>

<p>poco does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="geco">geco</h2>

<pre><code>  Signature: (a(n,n);int [o]ipvt(n);[o]rcond();[o]z(n))</code></pre>

<p>Factor a matrix using Gaussian elimination and estimate the condition number of the matrix.</p>

<p>geco does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="gefa">gefa</h2>

<pre><code>  Signature: (a(n,n);int [o]ipvt(n);int [o]info())</code></pre>

<p>Factor a matrix using Gaussian elimination.</p>

<p>gefa does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="podi">podi</h2>

<pre><code>  Signature: (a(n,n);[o]det(two=2);int job())</code></pre>

<p>Compute the determinant and inverse of a certain real symmetric positive definite matrix using the factors computed by <a href="#poco">poco</a>.</p>

<p>podi does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="gedi">gedi</h2>

<pre><code>  Signature: (a(n,n);int [o]ipvt(n);[o]det(two=2);[o]work(n);int job())</code></pre>

<p>Compute the determinant and inverse of a matrix using the factors computed by <a href="#geco">geco</a> or <a href="#gefa">gefa</a>.</p>

<p>gedi does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="gesl">gesl</h2>

<pre><code>  Signature: (a(lda,n);int ipvt(n);b(n);int job())</code></pre>

<p>Solve the real system <code>A*X=B</code> or <code>TRANS(A)*X=B</code> using the factors computed by <a href="#geco">geco</a> or <a href="#gefa">gefa</a>.</p>

<p>gesl does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="rs">rs</h2>

<pre><code>  Signature: (a(n,n);[o]w(n);int matz();[o]z(n,n);[t]fvone(n);[t]fvtwo(n);int [o]ierr())</code></pre>

<p>This subroutine calls the recommended sequence of subroutines from the eigensystem subroutine package (EISPACK) to find the eigenvalues and eigenvectors (if desired) of a REAL SYMMETRIC matrix.</p>

<p>rs does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="ezffti">ezffti</h2>

<pre><code>  Signature: (int n();[o]wsave(foo))</code></pre>

<p>Subroutine ezffti initializes the work array <code>wsave()</code> which is used in both <a href="#ezfftf">ezfftf</a> and <a href="#ezfftb">ezfftb</a>. The prime factorization of <code>n</code> together with a tabulation of the trigonometric functions are computed and stored in <code>wsave()</code>.</p>

<p>ezffti does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="ezfftf">ezfftf</h2>

<pre><code>  Signature: (r(n);[o]azero();[o]a(n);[o]b(n);wsave(foo))</code></pre>

<p>ezfftf does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="ezfftb">ezfftb</h2>

<pre><code>  Signature: ([o]r(n);azero();a(n);b(n);wsave(foo))</code></pre>

<p>ezfftb does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="pcoef">pcoef</h2>

<pre><code>  Signature: (int l();c();[o]tc(bar);a(foo))</code></pre>

<p>Convert the <code>polfit</code> coefficients to Taylor series form. <code>c</code> and <code>a()</code> must be of the same type.</p>

<p>pcoef does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="pvalue">pvalue</h2>

<pre><code>  Signature: (int l();x();[o]yfit();[o]yp(nder);a(foo))</code></pre>

<p>Use the coefficients generated by <code>polfit</code> to evaluate the polynomial fit of degree <code>l</code>, along with the first <code>nder</code> of its derivatives, at a specified point. <code>x</code> and <code>a</code> must be of the same type.</p>

<p>pvalue does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chim">chim</h2>

<pre><code>  Signature: (x(n);f(n);[o]d(n);int [o]ierr())</code></pre>

<p>Calculate the derivatives of (x,f(x)) using cubic Hermite interpolation.</p>

<p>Calculate the derivatives at the given set of points (<code>$x,$f</code>, where <code>$x</code> is strictly increasing). The resulting set of points - <code>$x,$f,$d</code>, referred to as the cubic Hermite representation - can then be used in other functions, such as <a href="#chfe">chfe</a>, <a href="#chfd">chfd</a>, and <a href="#chia">chia</a>.</p>

<p>The boundary conditions are compatible with monotonicity, and if the data are only piecewise monotonic, the interpolant will have an extremum at the switch points; for more control over these issues use <a href="#chic">chic</a>.</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>&gt; 0 if there were <code>ierr</code> switches in the direction of monotonicity (data still valid).</p>

</li>
<li><p>-1 if <code>nelem($x) &lt; 2</code>.</p>

</li>
<li><p>-3 if <code>$x</code> is not strictly increasing.</p>

</li>
</ul>

<p>chim does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chic">chic</h2>

<pre><code>  Signature: (int ic(two=2);vc(two=2);mflag();x(n);f(n);[o]d(n);wk(nwk);int [o]ierr())</code></pre>

<p>Calculate the derivatives of (x,f(x)) using cubic Hermite interpolation.</p>

<p>Calculate the derivatives at the given points (<code>$x,$f</code>, where <code>$x</code> is strictly increasing). Control over the boundary conditions is given by the <code>$ic</code> and <code>$vc</code> piddles, and the value of <code>$mflag</code> determines the treatment of points where monotoncity switches direction. A simpler, more restricted, interface is available using <a href="#chim">chim</a>.</p>

<p>The first and second elements of <code>$ic</code> determine the boundary conditions at the start and end of the data respectively. If the value is 0, then the default condition, as used by <a href="#chim">chim</a>, is adopted. If greater than zero, no adjustment for monotonicity is made, otherwise if less than zero the derivative will be adjusted. The allowed magnitudes for <code>ic(0)</code> are:</p>

<ul>

<li><p>1 if first derivative at <code>x(0)</code> is given in <code>vc(0)</code>.</p>

</li>
<li><p>2 if second derivative at <code>x(0)</code> is given in <code>vc(0)</code>.</p>

</li>
<li><p>3 to use the 3-point difference formula for <code>d(0)</code>. (Reverts to the default b.c. if <code>n &lt; 3</code>)</p>

</li>
<li><p>4 to use the 4-point difference formula for <code>d(0)</code>. (Reverts to the default b.c. if <code>n &lt; 4</code>)</p>

</li>
<li><p>5 to set <code>d(0)</code> so that the second derivative is continuous at <code>x(1)</code>. (Reverts to the default b.c. if <code>n &lt; 4</code>)</p>

</li>
</ul>

<p>The values for <code>ic(1)</code> are the same as above, except that the first-derivative value is stored in <code>vc(1)</code> for cases 1 and 2. The values of <code>$vc</code> need only be set if options 1 or 2 are chosen for <code>$ic</code>.</p>

<p>Set <code>$mflag = 0</code> if interpolant is required to be monotonic in each interval, regardless of the data. This causes <code>$d</code> to be set to 0 at all switch points. Set <code>$mflag</code> to be non-zero to use a formula based on the 3-point difference formula at switch points. If <code>$mflag &gt; 0</code>, then the interpolant at swich points is forced to not deviate from the data by more than <code>$mflag*dfloc</code>, where <code>dfloc</code> is the maximum of the change of <code>$f</code> on this interval and its two immediate neighbours. If <code>$mflag &lt; 0</code>, no such control is to be imposed.</p>

<p>The piddle <code>$wk</code> is only needed for work space. However, I could not get it to work as a temporary variable, so you must supply it; it is a 1D piddle with <code>2*n</code> elements.</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>1 if <code>ic(0) &lt; 0</code> and <code>d(0)</code> had to be adjusted for monotonicity.</p>

</li>
<li><p>2 if <code>ic(1) &lt; 0</code> and <code>d(n-1)</code> had to be adjusted for monotonicity.</p>

</li>
<li><p>3 if both 1 and 2 are true.</p>

</li>
<li><p>-1 if <code>n &lt; 2</code>.</p>

</li>
<li><p>-3 if <code>$x</code> is not strictly increasing.</p>

</li>
<li><p>-4 if <code>abs(ic(0)) &gt; 5</code>.</p>

</li>
<li><p>-5 if <code>abs(ic(1)) &gt; 5</code>.</p>

</li>
<li><p>-6 if both -4 and -5 are true.</p>

</li>
<li><p>-7 if <code>nwk &lt; 2*(n-1)</code>.</p>

</li>
</ul>

<p>chic does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chsp">chsp</h2>

<pre><code>  Signature: (int ic(two=2);vc(two=2);x(n);f(n);[o]d(n);wk(nwk);int [o]ierr())</code></pre>

<p>Calculate the derivatives of (x,f(x)) using cubic spline interpolation.</p>

<p>Calculate the derivatives, using cubic spline interpolation, at the given points (<code>$x,$f</code>), with the specified boundary conditions. Control over the boundary conditions is given by the <code>$ic</code> and <code>$vc</code> piddles. The resulting values - <code>$x,$f,$d</code> - can be used in all the functions which expect a cubic Hermite function.</p>

<p>The first and second elements of <code>$ic</code> determine the boundary conditions at the start and end of the data respectively. The allowed values for <code>ic(0)</code> are:</p>

<ul>

<li><p>0 to set <code>d(0)</code> so that the third derivative is continuous at <code>x(1)</code>.</p>

</li>
<li><p>1 if first derivative at <code>x(0)</code> is given in <code>vc(0</code>).</p>

</li>
<li><p>2 if second derivative at <code>x(0</code>) is given in <code>vc(0)</code>.</p>

</li>
<li><p>3 to use the 3-point difference formula for <code>d(0)</code>. (Reverts to the default b.c. if <code>n &lt; 3</code>.)</p>

</li>
<li><p>4 to use the 4-point difference formula for <code>d(0)</code>. (Reverts to the default b.c. if <code>n &lt; 4</code>.)</p>

</li>
</ul>

<p>The values for <code>ic(1)</code> are the same as above, except that the first-derivative value is stored in <code>vc(1)</code> for cases 1 and 2. The values of <code>$vc</code> need only be set if options 1 or 2 are chosen for <code>$ic</code>.</p>

<p>The piddle <code>$wk</code> is only needed for work space. However, I could not get it to work as a temporary variable, so you must supply it; it is a 1D piddle with <code>2*n</code> elements.</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>-1 if <code>nelem($x) &lt; 2</code>.</p>

</li>
<li><p>-3 if <code>$x</code> is not strictly increasing.</p>

</li>
<li><p>-4 if <code>ic(0) &lt; 0</code> or <code>ic(0) &gt; 4</code>.</p>

</li>
<li><p>-5 if <code>ic(1) &lt; 0</code> or <code>ic(1) &gt; 4</code>.</p>

</li>
<li><p>-6 if both of the above are true.</p>

</li>
<li><p>-7 if <code>nwk &lt; 2*n</code>.</p>

</li>
<li><p>-8 in case of trouble solving the linear system for the interior derivative values.</p>

</li>
</ul>

<p>chsp does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chfd">chfd</h2>

<pre><code>  Signature: (x(n);f(n);d(n);int check();xe(ne);[o]fe(ne);[o]de(ne);int [o]ierr())</code></pre>

<p>Interpolate function and derivative values.</p>

<p>Given a piecewise cubic Hermite function - such as from <a href="#chim">chim</a> - evaluate the function (<code>$fe</code>) and derivative (<code>$de</code>) at a set of points (<code>$xe</code>). If function values alone are required, use <a href="#chfe">chfe</a>. Set <code>check</code> to 0 to skip checks on the input data.</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>&gt;0 if extrapolation was performed at <code>ierr</code> points (data still valid).</p>

</li>
<li><p>-1 if <code>nelem($x) &lt; 2</code></p>

</li>
<li><p>-3 if <code>$x</code> is not strictly increasing.</p>

</li>
<li><p>-4 if <code>nelem($xe) &lt; 1</code>.</p>

</li>
<li><p>-5 if an error has occurred in a lower-level routine, which should never happen.</p>

</li>
</ul>

<p>chfd does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chfe">chfe</h2>

<pre><code>  Signature: (x(n);f(n);d(n);int check();xe(ne);[o]fe(ne);int [o]ierr())</code></pre>

<p>Interpolate function values.</p>

<p>Given a piecewise cubic Hermite function - such as from <a href="#chim">chim</a> - evaluate the function (<code>$fe</code>) at a set of points (<code>$xe</code>). If derivative values are also required, use <a href="#chfd">chfd</a>. Set <code>check</code> to 0 to skip checks on the input data.</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>&gt;0 if extrapolation was performed at <code>ierr</code> points (data still valid).</p>

</li>
<li><p>-1 if <code>nelem($x) &lt; 2</code></p>

</li>
<li><p>-3 if <code>$x</code> is not strictly increasing.</p>

</li>
<li><p>-4 if <code>nelem($xe) &lt; 1</code>.</p>

</li>
</ul>

<p>chfe does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chia">chia</h2>

<pre><code>  Signature: (x(n);f(n);d(n);int check();a();b();[o]ans();int [o]ierr())</code></pre>

<p>Integrate (x,f(x)) over arbitrary limits.</p>

<p>Evaluate the definite integral of a a piecewise cubic Hermite function over an arbitrary interval, given by <code>[$a,$b]</code>. See <a href="#chid">chid</a> if the integration limits are data points. Set <code>check</code> to 0 to skip checks on the input data.</p>

<p>The values of <code>$a</code> and <code>$b</code> do not have to lie within <code>$x</code>, although the resulting integral value will be highly suspect if they are not.</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>1 if <code>$a</code> lies outside <code>$x</code>.</p>

</li>
<li><p>2 if <code>$b</code> lies outside <code>$x</code>.</p>

</li>
<li><p>3 if both 1 and 2 are true.</p>

</li>
<li><p>-1 if <code>nelem($x) &lt; 2</code></p>

</li>
<li><p>-3 if <code>$x</code> is not strictly increasing.</p>

</li>
<li><p>-4 if an error has occurred in a lower-level routine, which should never happen.</p>

</li>
</ul>

<p>chia does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chid">chid</h2>

<pre><code>  Signature: (x(n);f(n);d(n);int check();int ia();int ib();[o]ans();int [o]ierr())</code></pre>

<p>Integrate (x,f(x)) between data points.</p>

<p>Evaluate the definite integral of a a piecewise cubic Hermite function between <code>x($ia)</code> and <code>x($ib)</code>.</p>

<p>See <a href="#chia">chia</a> for integration between arbitrary limits.</p>

<p>Although using a fortran routine, the values of <code>$ia</code> and <code>$ib</code> are zero offset. Set <code>check</code> to 0 to skip checks on the input data.</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>-1 if <code>nelem($x) &lt; 2</code>.</p>

</li>
<li><p>-3 if <code>$x</code> is not strictly increasing.</p>

</li>
<li><p>-4 if <code>$ia</code> or <code>$ib</code> is out of range.</p>

</li>
</ul>

<p>chid does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chcm">chcm</h2>

<pre><code>  Signature: (x(n);f(n);d(n);int check();int [o]ismon(n);int [o]ierr())</code></pre>

<p>Check the given piecewise cubic Hermite function for monotonicity.</p>

<p>The outout piddle <code>$ismon</code> indicates over which intervals the function is monotonic. Set <code>check</code> to 0 to skip checks on the input data.</p>

<p>For the data interval <code>[x(i),x(i+1)]</code>, the values of <code>ismon(i)</code> can be:</p>

<ul>

<li><p>-3 if function is probably decreasing</p>

</li>
<li><p>-1 if function is strictly decreasing</p>

</li>
<li><p>0 if function is constant</p>

</li>
<li><p>1 if function is strictly increasing</p>

</li>
<li><p>2 if function is non-monotonic</p>

</li>
<li><p>3 if function is probably increasing</p>

</li>
</ul>

<p>If <code>abs(ismon(i)) == 3</code>, the derivative values are near the boundary of the monotonicity region. A small increase produces non-monotonicity, whereas a decrease produces strict monotonicity.</p>

<p>The above applies to <code>i = 0 .. nelem($x)-1</code>. The last element of <code>$ismon</code> indicates whether the entire function is monotonic over $x.</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>-1 if <code>n &lt; 2</code>.</p>

</li>
<li><p>-3 if <code>$x</code> is not strictly increasing.</p>

</li>
</ul>

<p>chcm does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="chbs">chbs</h2>

<pre><code>  Signature: (x(n);f(n);d(n);int knotyp();int nknots();t(tsize);[o]bcoef(bsize);int [o]ndim();int [o]kord();int [o]ierr())</code></pre>

<p>Piecewise Cubic Hermite function to B-Spline converter.</p>

<p>The resulting B-spline representation of the data (i.e. <code>nknots</code>, <code>t</code>, <code>bcoeff</code>, <code>ndim</code>, and <code>kord</code>) can be evaluated by <code>bvalu</code> (which is currently not available).</p>

<p>Array sizes: <code>tsize = 2*n + 4</code>, <code>bsize = 2*n</code>, and <code>ndim = 2*n</code>.</p>

<p><code>knotyp</code> is a flag which controls the knot sequence. The knot sequence <code>t</code> is normally computed from <code>$x</code> by putting a double knot at each <code>x</code> and setting the end knot pairs according to the value of <code>knotyp</code> (where <code>m = ndim = 2*n</code>):</p>

<ul>

<li><p>0 - Quadruple knots at the first and last points.</p>

</li>
<li><p>1 - Replicate lengths of extreme subintervals: <code>t( 0 ) = t( 1 ) = x(0) - (x(1)-x(0))</code> and <code>t(m+3) = t(m+2) = x(n-1) + (x(n-1)-x(n-2))</code></p>

</li>
<li><p>2 - Periodic placement of boundary knots: <code>t( 0 ) = t( 1 ) = x(0) - (x(n-1)-x(n-2))</code> and <code>t(m+3) = t(m+2) = x(n) + (x(1)-x(0))</code></p>

</li>
<li><p>&lt;0 - Assume the <code>nknots</code> and <code>t</code> were set in a previous call.</p>

</li>
</ul>

<p><code>nknots</code> is the number of knots and may be changed by the routine. If <code>knotyp &gt;= 0</code>, <code>nknots</code> will be set to <code>ndim+4</code>, otherwise it is an input variable, and an error will occur if its value is not equal to <code>ndim+4</code>.</p>

<p><code>t</code> is the array of <code>2*n+4</code> knots for the B-representation and may be changed by the routine. If <code>knotyp &gt;= 0</code>, <code>t</code> will be changed so that the interior double knots are equal to the x-values and the boundary knots set as indicated above, otherwise it is assumed that <code>t</code> was set by a previous call (no check is made to verify that the data forms a legitimate knot sequence).</p>

<p>Error status returned by <code>$ierr</code>:</p>

<ul>

<li><p>0 if successful.</p>

</li>
<li><p>-4 if <code>knotyp &gt; 2</code>.</p>

</li>
<li><p>-5 if <code>knotyp &lt; 0</code> and <code>nknots != 2*n + 4</code>.</p>

</li>
</ul>

<p>chbs does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2 id="polfit">polfit</h2>

<pre><code>  Signature: (x(n); y(n); w(n); int maxdeg(); int [o]ndeg(); [o]eps(); [o]r(n); int [o]ierr(); [o]a(foo); [o]coeffs(bar);[t]xtmp(n);[t]ytmp(n);[t]wtmp(n);[t]rtmp(n))</code></pre>

<p>Fit discrete data in a least squares sense by polynomials in one variable. <code>x()</code>, <code>y()</code> and <code>w()</code> must be of the same type. This version handles bad values appropriately</p>

<p>polfit processes bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) 1997 Tuomas J. Lukka. Copyright (C) 2000 Tim Jenness, Doug Burke. All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>


</body>

</html>


